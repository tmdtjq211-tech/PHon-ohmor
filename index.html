<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ëŒ€í•™ì „ìŸ3 - ë¸”ë¡ ì˜¤ëª© (Strict Physics)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* UI ë ˆì´ì•„ì›ƒ */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* ìƒë‹¨ ì •ë³´ì°½ */
        #top-info { 
            pointer-events: auto; background: rgba(0, 0, 0, 0.8); padding: 10px 20px; 
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333;
        }
        .status-badge { font-weight: bold; padding: 5px 10px; border-radius: 4px; font-size: 14px; }
        
        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #bottom-panel { 
            pointer-events: auto; background: rgba(20, 20, 20, 0.95); padding: 15px; 
            border-top: 2px solid #4CAF50; border-radius: 15px 15px 0 0; 
            box-shadow: 0 -4px 20px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; gap: 10px;
        }

        .control-row { display: flex; gap: 10px; }
        button { 
            flex: 1; padding: 15px 0; cursor: pointer; background: #333; color: #fff; 
            border: 1px solid #555; border-radius: 8px; font-size: 16px; font-weight: bold; 
            transition: 0.2s; touch-action: manipulation;
        }
        button:active { background: #555; transform: scale(0.98); }
        
        #confirm-btn { 
            background: #4CAF50; color: #000; border: none; box-shadow: 0 0 10px rgba(76, 175, 80, 0.4); 
            display: none; 
        }
        
        /* ê²½ê³  í† ìŠ¤íŠ¸ ë©”ì‹œì§€ */
        #toast-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 50, 50, 0.9); color: white; padding: 15px 25px;
            border-radius: 30px; font-weight: bold; font-size: 16px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 1000;
            white-space: nowrap; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        /* ë¡œë¹„ */
        #lobby { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(20, 20, 20, 0.95); padding: 30px; border: 1px solid #4CAF50; 
            border-radius: 12px; text-align: center; pointer-events: auto; width: 80%; max-width: 300px;
        }
        input { width: 100%; padding: 12px; margin: 10px 0; background: #111; border: 1px solid #444; color: #fff; border-radius: 6px; text-align: center; font-size: 16px; }

        /* ì˜¤ë²„ë ˆì´ */
        #overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 500; pointer-events: auto; }
        .rps-btn { width: 80px; height: 80px; font-size: 35px; margin: 10px; background: #222; border: 2px solid #4CAF50; border-radius: 50%; display: inline-flex; justify-content: center; align-items: center; color: white; }
        
        #status-msg { position: absolute; top: 80px; width: 100%; text-align: center; font-size: 24px; font-weight: bold; color: #ffeb3b; text-shadow: 0 2px 4px #000; pointer-events: none; }
        .hidden { display: none !important; }
    </style>
    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js"
        } }
    </script>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="ui">
        <div id="top-info" class="hidden">
            <span id="role-label" class="status-badge" style="background:#333;">-</span>
            <span id="turn-label" class="status-badge" style="background:#333;">-</span>
            <span id="phase-ui" style="font-size:12px; color:#aaa;">ì°©ìˆ˜ ë‹¨ê³„</span>
        </div>

        <div id="lobby">
            <h1 style="color:#4CAF50; margin-bottom:20px;">BLOCK OMOK</h1>
            <button onclick="startMode('ai')">ğŸ¤– AI ì—°ìŠµ (ì‹±ê¸€)</button>
            <hr style="border-color:#333; margin:15px 0;">
            <input type="number" id="room-input" placeholder="ë°© ì½”ë“œ (ì˜ˆ: 55)" value="55">
            <button onclick="startMode('online')" style="border-color:#2196F3; color:#2196F3; background:transparent;">ğŸ‘¥ ì˜¨ë¼ì¸ ëŒ€ê²°</button>
        </div>

        <div id="bottom-panel" class="hidden">
            <button id="confirm-btn" onclick="confirmMove()">âœ… ì—¬ê¸°ì— ì°©ìˆ˜í•˜ê¸°</button>
            <div class="control-row">
                <button id="mode-btn" onclick="togglePlaceMode()">ëª¨ë“œ: ëˆ•íˆê¸°</button>
                <button onclick="rotatePiece()">íšŒì „ (R)</button>
                <button onclick="toggleTopView()">ì‹œì  (V)</button>
            </div>
            <button onclick="location.reload()" style="background:#220000; border-color:#550000; color:#ffaaaa; padding: 10px 0; font-size:14px; margin-top:5px;">ë‚˜ê°€ê¸°</button>
        </div>
    </div>

    <div id="toast-msg">ê²½ê³  ë©”ì‹œì§€</div>

    <div id="overlay-screen" class="hidden">
        <h2 id="overlay-title" style="color:#4CAF50;">ëŒ€ê¸° ì¤‘...</h2>
        <p id="match-status" style="color:#888;">ë°© ì½”ë“œ: <span id="display-room-id">-</span></p>
        <div id="rps-ui" class="hidden">
            <div style="display:flex;">
                <div class="rps-btn" onclick="chooseRPS('rock')">âœŠ</div>
                <div class="rps-btn" onclick="chooseRPS('paper')">âœ‹</div>
                <div class="rps-btn" onclick="chooseRPS('scissors')">âœŒï¸</div>
            </div>
        </div>
    </div>

    <div id="status-msg"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "firebase/app";
        import { getDatabase, ref, set, onValue, update } from "firebase/database";

        const firebaseConfig = {
            apiKey: "AIzaSyDcKWKTei9L2Sat-XxinlXknabIcHgmjGs",
            authDomain: "d454545-ac9b1.firebaseapp.com",
            projectId: "d454545-ac9b1",
            storageBucket: "d454545-ac9b1.firebasestorage.app",
            messagingSenderId: "438189498590",
            appId: "1:438189498590:web:5c515415a9aa1f2b5aa24f",
            measurementId: "G-BC09V1ZZT7",
            databaseURL: "https://d454545-ac9b1-default-rtdb.firebaseio.com"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        const state = {
            mode: 'ai', myRole: 'p1', currentTurn: 'p1', phase: 'place',
            board: Array(25).fill().map(() => []),
            pieces: [], placeCount: { p1: 1, p2: 1 },
            placeMode: 'flat', selectedId: null, rotation: 0, isTopView: true, winner: null, matchingId: null,
            pendingMove: null 
        };

        let scene, camera, renderer, controls, raycaster, mouse, ghostGroup, boardGroup, roomRef;
        const flatOffsets = [[[0,0,0], [1,0,0], [0,0,1]], [[0,0,0], [0,0,1], [-1,0,0]], [[0,0,0], [-1,0,0], [0,0,-1]], [[0,0,0], [0,0,-1], [1,0,0]]];
        const vertOffsets = [[[0,0,0], [0,1,0], [1,1,0]], [[0,0,0], [0,1,0], [0,1,1]], [[0,0,0], [0,1,0], [-1,1,0]], [[0,0,0], [0,1,0], [0,1,-1]]];
        function getOffsets(mode, rot) { return (mode === 'flat' ? flatOffsets : vertOffsets)[rot % 4]; }

        window.startMode = (mode) => {
            state.mode = mode;
            document.getElementById('lobby').classList.add('hidden');
            initThree();
            if (mode === 'online') {
                const id = document.getElementById('room-input').value;
                if(!id) return alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
                setupMatching(id);
            } else {
                setupInitialPieces();
                document.getElementById('top-info').classList.remove('hidden');
                document.getElementById('bottom-panel').classList.remove('hidden');
            }
        };

        function setupInitialPieces() {
            addPieceData('s1', 'p1', 1, 1, 0, 'flat');
            addPieceData('s2', 'p2', 3, 3, 2, 'flat');
            renderAll();
        }

        function setupMatching(id) {
            state.matchingId = id;
            document.getElementById('display-room-id').innerText = id;
            document.getElementById('overlay-screen').classList.remove('hidden');
            roomRef = ref(db, 'rooms/' + id);
            onValue(roomRef, (snap) => {
                const data = snap.val();
                if (!data) { state.myRole = 'host'; set(roomRef, { hostJoined: true, status: 'waiting' }); }
                else {
                    if (data.status === 'waiting' && state.myRole !== 'host') { state.myRole = 'guest'; update(roomRef, { status: 'matching_complete' }); }
                    if (data.status === 'matching_complete') { document.getElementById('overlay-title').innerText = "ë§¤ì¹­ ì™„ë£Œ!"; setTimeout(() => update(roomRef, { status: 'rps' }), 1000); }
                    if (data.status === 'rps') { document.getElementById('overlay-title').innerText = "ê°€ìœ„ë°”ìœ„ë³´!"; document.getElementById('rps-ui').classList.remove('hidden'); if(data.rps_host && data.rps_guest) judgeRPS(data.rps_host, data.rps_guest); }
                    if (data.status === 'playing') {
                        document.getElementById('overlay-screen').classList.add('hidden');
                        document.getElementById('top-info').classList.remove('hidden');
                        document.getElementById('bottom-panel').classList.remove('hidden');
                        const s = JSON.parse(data.gameState); state.currentTurn = s.currentTurn; state.phase = s.phase; state.pieces = s.pieces; state.placeCount = s.placeCount; state.winner = s.winner;
                        rebuildBoard(); renderAll(); updateUI();
                    }
                }
            });
        }
        window.chooseRPS = (choice) => { const updates = {}; updates[state.myRole==='host'?'rps_host':'rps_guest']=choice; update(roomRef, updates); document.getElementById('rps-ui').classList.add('hidden'); document.getElementById('overlay-title').innerText="ìƒëŒ€ ëŒ€ê¸° ì¤‘..."; };
        function judgeRPS(h, g) {
            if (h===g) { if(state.myRole==='host') setTimeout(()=>update(roomRef,{rps_host:null,rps_guest:null}),1000); document.getElementById('overlay-title').innerText="ë¬´ìŠ¹ë¶€!"; document.getElementById('rps-ui').classList.remove('hidden'); return; }
            const winMap = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
            const hostWins = winMap[h] === g;
            state.myRole = (state.myRole==='host'?(hostWins?'p1':'p2'):(hostWins?'p2':'p1'));
            if (state.myRole==='p1') {
                const initS = { currentTurn:'p1', phase:'place', pieces:[{id:'s1',owner:'p1',x:1,z:1,rot:0,mode:'flat'},{id:'s2',owner:'p2',x:3,z:3,rot:2,mode:'flat'}], placeCount:{p1:1,p2:1} };
                update(roomRef, { status: 'playing', gameState: JSON.stringify(initS) });
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 6);
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5); light.position.set(5, 10, 2); scene.add(light);
            scene.add(new THREE.GridHelper(5, 5, 0x4CAF50, 0x222222));
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5,5), new THREE.MeshStandardMaterial({color:0x0a0a0a}));
            floor.rotation.x = -Math.PI/2; floor.name = "floor"; scene.add(floor);
            ghostGroup = new THREE.Group(); boardGroup = new THREE.Group(); scene.add(ghostGroup, boardGroup);
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            animate();
        }

        function createCube(x, y, z, color, isSelected) {
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), new THREE.MeshStandardMaterial({ color }));
            mesh.position.set(x-2, y+0.5, z-2);
            group.add(mesh);
            const edgeMat = new THREE.LineBasicMaterial({ color: isSelected?0xffffff:0x000000, transparent:!isSelected, opacity:isSelected?1:0.2 });
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), edgeMat);
            edges.position.copy(mesh.position);
            group.add(edges);
            return group;
        }

        function renderAll() {
            boardGroup.clear();
            state.board.forEach((stack, idx) => {
                stack.forEach(c => boardGroup.add(createCube(idx%5, c.layer, Math.floor(idx/5), c.owner==='p1'?0xaa0000:0x0055aa, state.selectedId===c.pieceId)));
            });
            checkWin(); updateUI();
        }

        function rebuildBoard() {
            state.board = Array(25).fill().map(() => []);
            state.pieces.forEach(p => {
                getOffsets(p.mode, p.rot).forEach(o => {
                    const idx = (p.z+o[2])*5 + (p.x+o[0]);
                    if(state.board[idx]) state.board[idx].push({ owner:p.owner, pieceId:p.id, layer:o[1] });
                });
            });
        }

        // ==========================================
        //  í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ê¸°ëŠ¥
        // ==========================================
        function showToast(msg) {
            const toast = document.getElementById('toast-msg');
            toast.innerText = msg;
            toast.style.opacity = '1';
            clearTimeout(window.toastTimer);
            window.toastTimer = setTimeout(() => {
                toast.style.opacity = '0';
            }, 1500);
        }

        // ==========================================
        // ğŸ”¥ ê²€ì¦ ë¡œì§ (ì—„ê²©í•œ ë¬¼ë¦¬ ë²•ì¹™)
        // ==========================================
        function validateMove(gx, gz, rot, mode, ignoreId = null) {
            const offsets = getOffsets(mode, rot);
            
            // 1. ë²”ìœ„ ì²´í¬
            if(!offsets.every(o => {
                const nx = gx + o[0]; const nz = gz + o[2];
                return nx >= 0 && nx < 5 && nz >= 0 && nz < 5;
            })) return { valid: false, msg: "ê²½ê¸°ì¥ì„ ë²—ì–´ë‚©ë‹ˆë‹¤!" };

            const tempBoard = JSON.parse(JSON.stringify(state.board));
            if(ignoreId) for(let i=0; i<25; i++) tempBoard[i] = tempBoard[i].filter(c => c.pieceId !== ignoreId);

            // 2. ì¶©ëŒ ë° ì¤‘ë ¥ ì²´í¬
            for (let i = 0; i < offsets.length; i++) {
                const o = offsets[i];
                const nx = gx + o[0];
                const nz = gz + o[2];
                const ny = o[1];

                // ì´ë¯¸ ë¸”ë¡ì´ ìˆëŠ”ê°€?
                if (tempBoard[nz*5 + nx].some(c => c.layer === ny)) return { valid: false, msg: "ì´ë¯¸ ë¸”ë¡ì´ ìˆìŠµë‹ˆë‹¤!" };

                // ë°”ë‹¥ì´ ì•„ë‹Œ ê²½ìš°, ì•„ë˜ì— ë°›ì¹¨ì´ ìˆëŠ”ê°€?
                if (ny > 0) {
                    const hasBoardSupport = tempBoard[nz*5 + nx].some(c => c.layer === ny - 1);
                    const hasSelfSupport = offsets.some(other => other[0] === o[0] && other[2] === o[2] && other[1] === ny - 1);
                    
                    // 3ê°œ ì¤‘ í•˜ë‚˜ë¼ë„ ë–  ìˆìœ¼ë©´ ì•ˆë¨
                    if (!hasBoardSupport && !hasSelfSupport) return { valid: false, msg: "ê³µì¤‘ì— ë–  ìˆìŠµë‹ˆë‹¤! (ë°›ì¹¨ í•„ìš”)" };
                }
            }
            return { valid: true };
        }

        // ë‹¨ìˆœ boolean ë°˜í™˜ìš© (AI ë“±ì—ì„œ ì‚¬ìš©)
        function canPlace(gx, gz, rot, mode, ignoreId = null) {
            return validateMove(gx, gz, rot, mode, ignoreId).valid;
        }

        function handleCellClick(gx, gz) {
            if(state.winner || state.currentTurn !== state.myRole) return;
            state.pendingMove = null;
            document.getElementById('confirm-btn').style.display = 'none';

            if(state.phase === 'place') {
                const check = validateMove(gx, gz, state.rotation, state.placeMode);
                if(check.valid) {
                    state.pendingMove = { type: 'place', x: gx, z: gz, rot: state.rotation, mode: state.placeMode };
                    document.getElementById('confirm-btn').style.display = 'block';
                } else {
                    showToast(check.msg);
                }
            } else {
                const stack = state.board[gz*5+gx];
                const top = stack.length > 0 ? stack.sort((a,b)=>b.layer-a.layer)[0] : null;
                if(!state.selectedId) {
                    if(top && top.owner === state.myRole) {
                        state.selectedId = top.pieceId;
                        const p = state.pieces.find(pc => pc.id === state.selectedId);
                        state.rotation = p.rot; state.placeMode = p.mode; renderAll();
                    }
                } else {
                    const check = validateMove(gx, gz, state.rotation, state.placeMode, state.selectedId);
                    if(check.valid) {
                         state.pendingMove = { type: 'move', x: gx, z: gz, rot: state.rotation, mode: state.placeMode };
                         document.getElementById('confirm-btn').style.display = 'block';
                    } else { 
                        state.selectedId = null; renderAll(); 
                        showToast(check.msg);
                    }
                }
            }
        }

        window.confirmMove = () => {
            if (!state.pendingMove) return;
            const pm = state.pendingMove;
            if (pm.type === 'place') {
                addPieceData(Math.random().toString(36), state.myRole, pm.x, pm.z, pm.rot, pm.mode);
                state.placeCount[state.myRole]++;
                finishTurn();
            } else if (pm.type === 'move') {
                const p = state.pieces.find(pc => pc.id === state.selectedId);
                Object.assign(p, { x: pm.x, z: pm.z, rot: pm.rot, mode: pm.mode });
                state.selectedId = null;
                finishTurn();
            }
            state.pendingMove = null;
            document.getElementById('confirm-btn').style.display = 'none';
        };

        function finishTurn() {
            state.currentTurn = state.currentTurn === 'p1' ? 'p2' : 'p1';
            if(state.placeCount.p1 >= 5 && state.placeCount.p2 >= 5) state.phase = 'move';
            if(state.mode === 'online') pushOnline();
            else { rebuildBoard(); renderAll(); if(state.mode === 'ai' && state.currentTurn === 'p2') doAI(); }
        }

        function pushOnline() {
            const data = { currentTurn: state.currentTurn, phase: state.phase, pieces: state.pieces, placeCount: state.placeCount, winner: state.winner };
            update(roomRef, { gameState: JSON.stringify(data) });
        }

        function addPieceData(id, owner, x, z, rot, mode) {
            state.pieces.push({ id, owner, x, z, rot, mode });
            rebuildBoard();
        }

        function checkWin() {
            const top = state.board.map(s => s.length > 0 ? s.sort((a,b)=>b.layer-a.layer)[0].owner : null);
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            for(let l of lines) {
                if(top[l[0]] && l.every(i => top[i] === top[l[0]])) {
                    state.winner = top[l[0]];
                    document.getElementById('status-msg').innerText = (state.winner === 'p1' ? 'ë¹¨ê°•' : 'íŒŒë‘') + "íŒ€ ìŠ¹ë¦¬!";
                }
            }
        }

        function doAI() {
            if (state.winner || state.currentTurn !== 'p2') return;
            setTimeout(() => {
                const moves = getAllValidMoves('p2');
                if (moves.length === 0) return;
                moves.forEach(m => m.score = evaluateBoardState(m, 'p2'));
                moves.sort((a, b) => b.score - a.score);
                const best = moves[0];
                if (state.phase === 'place') {
                    addPieceData(Math.random().toString(36), 'p2', best.x, best.z, best.r, best.m);
                    state.placeCount.p2++;
                } else {
                    const p = state.pieces.find(pc => pc.id === best.targetId);
                    Object.assign(p, { x: best.x, z: best.z, rot: best.r, mode: best.m });
                    rebuildBoard();
                }
                finishTurn();
            }, 500);
        }
        function getAllValidMoves(player) {
            const validMoves = [];
            const modes = ['flat', 'vertical'];
            for (let x = 0; x < 5; x++) {
                for (let z = 0; z < 5; z++) {
                    for (let r = 0; r < 4; r++) {
                        for (let m of modes) {
                            if (state.phase === 'place') {
                                if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m });
                            } else {
                                state.pieces.filter(p => p.owner === player).forEach(targetPiece => {
                                    const backupBoard = JSON.parse(JSON.stringify(state.board));
                                    state.board = state.board.map(s => s.filter(c => c.pieceId !== targetPiece.id));
                                    if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m, targetId: targetPiece.id });
                                    state.board = backupBoard;
                                });
                            }
                        }
                    }
                }
            }
            return validMoves;
        }
        function evaluateBoardState(move, aiPlayer) {
            const humanPlayer = aiPlayer === 'p1' ? 'p2' : 'p1';
            let totalScore = 0;
            const offsets = getOffsets(move.m, move.r);
            let simTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            offsets.forEach(o => { const idx = (move.z + o[2]) * 5 + (move.x + o[0]); simTop[idx] = aiPlayer; });
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            totalScore += evaluateLines(lines, simTop, aiPlayer, humanPlayer) * 1.2; 
            let currentTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            let opponentThreatScore = evaluateLines(lines, currentTop, humanPlayer, aiPlayer);
            if (opponentThreatScore > 5000) totalScore += opponentThreatScore * 10;
            else totalScore += opponentThreatScore * 0.8;
            if (move.x === 2 && move.z === 2) totalScore += 50;
            return totalScore;
        }
        function evaluateLines(lines, boardState, me, opp) {
            let score = 0;
            for (let l of lines) {
                let myCnt = 0, oppCnt = 0, emptyCnt = 0;
                let pattern = "";
                l.forEach(i => { if (boardState[i] === me) { myCnt++; pattern += "O"; } else if (boardState[i] === opp) { oppCnt++; pattern += "X"; } else { emptyCnt++; pattern += "_"; } });
                if (oppCnt === 0) { 
                    if (myCnt === 5) score += 1000000; 
                    else if (myCnt === 4) score += 50000; 
                    else if (myCnt === 3) { if (pattern.includes("_OOO_") || pattern.includes("_OOO") || pattern.includes("OOO_")) score += 5000; else score += 1000; }
                    else if (myCnt === 2 && emptyCnt === 3) score += 100;
                }
            }
            return score;
        }

        function updateUI() {
            document.getElementById('role-label').innerText = state.myRole==='p1'?"ğŸ”´ ë‚˜ (ì„ )":state.myRole==='p2'?"ğŸ”µ ë‚˜ (í›„)":"ê´€ì „";
            document.getElementById('turn-label').innerText = state.currentTurn===state.myRole?"ë‚´ í„´":"ìƒëŒ€ í„´";
            document.getElementById('turn-label').style.color = state.currentTurn === state.myRole ? '#4CAF50' : '#888';
            document.getElementById('phase-ui').innerText = state.phase === 'place' ? "ì°©ìˆ˜ ë‹¨ê³„" : "ì´ë™ ë‹¨ê³„";
        }

        function animate() {
            requestAnimationFrame(animate); controls.update(); ghostGroup.clear();
            
            if(state.pendingMove) {
                const pm = state.pendingMove;
                getOffsets(pm.mode, pm.rot).forEach(o => ghostGroup.add(createCube(pm.x+o[0], o[1], pm.z+o[2], 0x4CAF50, false)));
            } else if(!state.winner && state.currentTurn === state.myRole) {
                raycaster.setFromCamera(mouse, camera);
                const floor = raycaster.intersectObjects(scene.children).find(h => h.object.name === "floor");
                if(floor) {
                    const gx = Math.round(floor.point.x+2), gz = Math.round(floor.point.z+2);
                    if(canPlace(gx, gz, state.rotation, state.placeMode, state.selectedId)) {
                        getOffsets(state.placeMode, state.rotation).forEach(o => ghostGroup.add(createCube(gx+o[0], o[1], gz+o[2], 0x444444, false)));
                    }
                }
            }
            renderer.render(scene, camera);
        }

        window.rotatePiece = () => { 
            state.rotation++; 
            if(state.pendingMove) { state.pendingMove.rot = state.rotation; }
        };
        window.togglePlaceMode = () => { 
            state.placeMode = state.placeMode === 'flat' ? 'vertical' : 'flat'; 
            document.getElementById('mode-btn').innerText = `ëª¨ë“œ: ${state.placeMode === 'flat' ? 'ëˆ•íˆê¸°' : 'ì„¸ìš°ê¸°'}`; 
            if(state.pendingMove) { state.pendingMove.mode = state.placeMode; }
        };
        window.toggleTopView = () => { state.isTopView = !state.isTopView; if(state.isTopView) { camera.position.set(0, 12, 6); camera.lookAt(0,0,0); controls.enabled = false; } else { camera.position.set(6, 7, 6); controls.enabled = true; } };

        const updateM = (x, y) => { mouse.x = (x/window.innerWidth)*2-1; mouse.y = -(y/window.innerHeight)*2+1; };
        const clk = (e) => { 
            const x = e.clientX||(e.touches&&e.touches[0].clientX); 
            const y = e.clientY||(e.touches&&e.touches[0].clientY); 
            if(x) updateM(x, y); 
            raycaster.setFromCamera(mouse, camera); 
            const f = raycaster.intersectObjects(scene.children).find(h => h.object.name === "floor"); 
            if(f) handleCellClick(Math.round(f.point.x+2), Math.round(f.point.z+2)); 
        };
        window.addEventListener('mousemove', (e) => updateM(e.clientX, e.clientY)); 
        window.addEventListener('click', clk); 
        window.addEventListener('touchstart', clk);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
