<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ëŒ€í•™ì „ìŸ3 - ë¸”ë¡ ì˜¤ëª© (Perfect Match)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; }
        
        #debug-console {
            position: absolute; bottom: 100px; left: 10px; width: 300px; height: 150px;
            background: rgba(0,0,0,0.8); border: 1px solid #2196F3; color: #fff;
            font-size: 11px; overflow-y: scroll; pointer-events: auto; padding: 5px;
            z-index: 9999; font-family: monospace; display: block;
        }

        #top-info { 
            pointer-events: auto; background: rgba(0, 0, 0, 0.8); padding: 10px 20px; 
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333;
        }
        .status-badge { font-weight: bold; padding: 5px 10px; border-radius: 4px; font-size: 14px; }
        
        #bottom-panel { 
            pointer-events: auto; background: rgba(20, 20, 20, 0.95); padding: 15px; 
            border-top: 2px solid #4CAF50; border-radius: 15px 15px 0 0; 
            box-shadow: 0 -4px 20px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; gap: 10px;
        }

        .control-row { display: flex; gap: 10px; }
        button { 
            flex: 1; padding: 15px 0; cursor: pointer; background: #333; color: #fff; 
            border: 1px solid #555; border-radius: 8px; font-size: 16px; font-weight: bold; 
            transition: 0.2s; touch-action: manipulation;
        }
        button:active { background: #555; transform: scale(0.98); }
        
        #confirm-btn { 
            background: #4CAF50; color: #000; border: none; box-shadow: 0 0 10px rgba(76, 175, 80, 0.4); 
            display: none; 
        }
        
        #toast-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 50, 50, 0.9); color: white; padding: 15px 25px;
            border-radius: 30px; font-weight: bold; font-size: 16px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 1000;
            white-space: nowrap; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        #lobby { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(20, 20, 20, 0.95); padding: 30px; border: 1px solid #4CAF50; 
            border-radius: 12px; text-align: center; pointer-events: auto; width: 80%; max-width: 300px;
        }
        
        #overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 500; pointer-events: auto; }
        .rps-btn { width: 80px; height: 80px; font-size: 35px; margin: 10px; background: #222; border: 2px solid #4CAF50; border-radius: 50%; display: inline-flex; justify-content: center; align-items: center; color: white; cursor: pointer; }
        
        #status-msg { position: absolute; top: 80px; width: 100%; text-align: center; font-size: 24px; font-weight: bold; color: #ffeb3b; text-shadow: 0 2px 4px #000; pointer-events: none; }
        .hidden { display: none !important; }
        
        .loader { border: 5px solid #333; border-top: 5px solid #4CAF50; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js",
            "firebase/analytics": "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js"
        } }
    </script>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="ui">
        <div id="top-info" class="hidden">
            <span id="role-label" class="status-badge" style="background:#333;">-</span>
            <span id="turn-label" class="status-badge" style="background:#333;">-</span>
            <span id="phase-ui" style="font-size:12px; color:#aaa;">ì°©ìˆ˜ ë‹¨ê³„</span>
        </div>

        <div id="lobby">
            <h1 style="color:#4CAF50; margin-bottom:20px;">BLOCK OMOK</h1>
            <p style="color:#888; font-size:12px; margin-bottom:20px;">ë§¤ì¹­ ì‹œìŠ¤í…œ ê°•í™”ë¨</p>
            <button onclick="startMode('ai')">ğŸ¤– AI ì—°ìŠµ (ì‹±ê¸€)</button>
            <hr style="border-color:#333; margin:15px 0;">
            <button onclick="startMode('online')" style="border-color:#2196F3; color:#2196F3; background:transparent;">âš¡ ë¹ ë¥¸ ë§¤ì¹­ (Online)</button>
        </div>
        
        <div id="debug-console">ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ.<br></div>

        <div id="bottom-panel" class="hidden">
            <button id="confirm-btn" onclick="confirmMove()">âœ… ì—¬ê¸°ì— ì°©ìˆ˜í•˜ê¸°</button>
            <div class="control-row">
                <button id="mode-btn" onclick="togglePlaceMode()">ëª¨ë“œ: ëˆ•íˆê¸°</button>
                <button onclick="rotatePiece()">íšŒì „ (R)</button>
                <button onclick="toggleTopView()">ì‹œì  (V)</button>
            </div>
            <button onclick="location.reload()" style="background:#220000; border-color:#550000; color:#ffaaaa; padding: 10px 0; font-size:14px; margin-top:5px;">ë‚˜ê°€ê¸°</button>
        </div>
    </div>

    <div id="toast-msg">ê²½ê³  ë©”ì‹œì§€</div>

    <div id="overlay-screen" class="hidden">
        <h2 id="overlay-title" style="color:#4CAF50;">ëŒ€ê¸° ì¤‘...</h2>
        <div id="loading-spinner" class="loader hidden"></div>
        <p id="match-status" style="color:#888; font-size: 14px; margin-top: 10px;">ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤...</p>
        
        <div id="rps-ui" class="hidden">
            <div style="display:flex;">
                <div class="rps-btn" onclick="chooseRPS('rock')">âœŠ</div>
                <div class="rps-btn" onclick="chooseRPS('paper')">âœ‹</div>
                <div class="rps-btn" onclick="chooseRPS('scissors')">âœŒï¸</div>
            </div>
        </div>
    </div>

    <div id="status-msg"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "firebase/app";
        import { getDatabase, ref, set, onValue, update, push, get, query, limitToFirst, orderByChild, equalTo, runTransaction } from "firebase/database";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "firebase/auth";

        function log(msg) {
            const consoleDiv = document.getElementById('debug-console');
            const time = new Date().toLocaleTimeString();
            consoleDiv.innerHTML += `[${time}] ${msg}<br>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            console.log(`[SYS] ${msg}`);
        }

        const firebaseConfig = {
            apiKey: "AIzaSyB-wYr-_N-ZaPGJon_mj2OsNgG472b1gw8",
            authDomain: "dddaaa-51437.firebaseapp.com",
            databaseURL: "https://dddaaa-51437-default-rtdb.firebaseio.com",
            projectId: "dddaaa-51437",
            storageBucket: "dddaaa-51437.firebasestorage.app",
            messagingSenderId: "372926322507",
            appId: "1:372926322507:web:01c2064521dbd81897bace",
            measurementId: "G-PCTWYEF35C"
        };

        let app, db, auth, myUid;

        try {
            app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            auth = getAuth(app);
            log("Firebase ë¡œë“œë¨");

            signInAnonymously(auth).catch((error) => {
                log("âŒ ë¡œê·¸ì¸ ì—ëŸ¬: " + error.message);
            });

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    myUid = user.uid;
                    log(`âœ… ë¡œê·¸ì¸ ì„±ê³µ (ID: ${myUid.slice(0,5)})`);
                }
            });

        } catch (e) {
            log("âŒ ì´ˆê¸°í™” ì—ëŸ¬: " + e.message);
        }

        const state = {
            mode: 'ai', myRole: 'p1', currentTurn: 'p1', phase: 'place',
            board: Array(25).fill().map(() => []),
            pieces: [], placeCount: { p1: 1, p2: 1 },
            placeMode: 'flat', selectedId: null, rotation: 0, isTopView: true, winner: null, matchingId: null,
            pendingMove: null 
        };

        let scene, camera, renderer, controls, raycaster, mouse, ghostGroup, boardGroup, roomRef;
        const flatOffsets = [[[0,0,0], [1,0,0], [0,0,1]], [[0,0,0], [0,0,1], [-1,0,0]], [[0,0,0], [-1,0,0], [0,0,-1]], [[0,0,0], [0,0,-1], [1,0,0]]];
        const vertOffsets = [[[0,0,0], [0,1,0], [1,1,0]], [[0,0,0], [0,1,0], [0,1,1]], [[0,0,0], [0,1,0], [-1,1,0]], [[0,0,0], [0,1,0], [0,1,-1]]];
        function getOffsets(mode, rot) { return (mode === 'flat' ? flatOffsets : vertOffsets)[rot % 4]; }

        window.startMode = (mode) => {
            if (mode === 'online' && !myUid) {
                alert("ì„œë²„ ë¡œê·¸ì¸ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.");
                return;
            }
            state.mode = mode;
            document.getElementById('lobby').classList.add('hidden');
            initThree();
            if (mode === 'online') {
                findAndJoinMatch(); 
            } else {
                setupInitialPieces();
                document.getElementById('top-info').classList.remove('hidden');
                document.getElementById('bottom-panel').classList.remove('hidden');
                document.getElementById('debug-console').classList.add('hidden'); 
            }
        };

        // ==========================================
        // ğŸ”¥ ê°œì„ ëœ ë§¤ì¹­ ë¡œì§ (waiting ìƒíƒœë§Œ ì •ë°€ ê²€ìƒ‰)
        // ==========================================
        async function findAndJoinMatch() {
            document.getElementById('overlay-screen').classList.remove('hidden');
            document.getElementById('overlay-title').innerText = "ë§¤ì¹­ ì¤‘...";
            document.getElementById('loading-spinner').classList.remove('hidden');
            document.getElementById('match-status').innerText = "ë¹ˆ ë°© ê²€ìƒ‰ ì¤‘...";
            log("ë§¤ì¹­ ì‹œì‘ (ì •ë°€ ê²€ìƒ‰)...");

            try {
                const roomsRef = ref(db, 'rooms');
                
                // ğŸš¨ ì¤‘ìš”: 'waiting' ìƒíƒœì¸ ë°©ë§Œ ìµœëŒ€ 50ê°œ ê°€ì ¸ì˜µë‹ˆë‹¤.
                // ì´ ì¿¼ë¦¬ê°€ ì‘ë™í•˜ë ¤ë©´ Rulesì— .indexOnì´ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
                const waitingQuery = query(roomsRef, orderByChild("status"), equalTo("waiting"), limitToFirst(50));
                
                const snapshot = await get(waitingQuery); 
                let joinedRoomId = null;

                if (snapshot.exists()) {
                    const rooms = snapshot.val();
                    const roomIds = Object.keys(rooms);
                    log(`ëŒ€ê¸° ì¤‘ì¸ ë°© ${roomIds.length}ê°œ ë°œê²¬`);
                    
                    for (let id of roomIds) {
                        const targetRoomRef = ref(db, `rooms/${id}`);
                        
                        const result = await runTransaction(targetRoomRef, (currentData) => {
                            if (currentData && currentData.status === 'waiting') {
                                currentData.status = 'matching_complete';
                                currentData.guestId = myUid; 
                                return currentData;
                            }
                            return;
                        });

                        if (result.committed) {
                            joinedRoomId = id;
                            state.myRole = 'guest'; 
                            log(`âœ… ë°© ì…ì¥ ì„±ê³µ: ${id}`);
                            setupRoomListener(joinedRoomId);
                            break;
                        }
                    }
                } else {
                    log("ëŒ€ê¸° ì¤‘ì¸ ë°©ì´ í•˜ë‚˜ë„ ì—†ìŠµë‹ˆë‹¤.");
                }

                if (!joinedRoomId) {
                    log("ìƒˆ ë°©ì„ ìƒì„±í•©ë‹ˆë‹¤ (Host)");
                    const newRoomRef = push(roomsRef);
                    joinedRoomId = newRoomRef.key;
                    state.myRole = 'host';
                    
                    await set(newRoomRef, { 
                        status: 'waiting', 
                        hostId: myUid, 
                        createdAt: Date.now() 
                    });
                    log(`âœ… ë°© ìƒì„± ì™„ë£Œ: ${joinedRoomId}`);
                    setupRoomListener(joinedRoomId);
                }
            } catch (err) {
                log(`ğŸš¨ ì—ëŸ¬: ${err.message}`);
                
                if(err.message.includes("index")) {
                    alert("íŒŒì´ì–´ë² ì´ìŠ¤ Rulesì— ì¸ë±ìŠ¤ ì„¤ì •ì„ ì•ˆ í•˜ì…¨ìŠµë‹ˆë‹¤! (ë§¤ë‰´ì–¼ 1ë‹¨ê³„ ì°¸ê³ )");
                    document.getElementById('match-status').innerText = "ì˜¤ë¥˜: Index ì„¤ì • í•„ìš”";
                } else {
                    document.getElementById('match-status').innerText = "ì˜¤ë¥˜: " + err.message;
                }
            }
        }

        function setupRoomListener(id) {
            state.matchingId = id;
            roomRef = ref(db, 'rooms/' + id);
            
            onValue(roomRef, (snap) => {
                const data = snap.val();
                if (!data) return; 

                if (data.status === 'matching_complete') {
                    document.getElementById('overlay-title').innerText = "ë§¤ì¹­ ì™„ë£Œ!";
                    document.getElementById('match-status').innerText = "ê²Œì„ ì¤€ë¹„ ì¤‘...";
                    document.getElementById('loading-spinner').classList.add('hidden');
                    
                    if (state.myRole === 'host') {
                        setTimeout(() => update(roomRef, { status: 'rps' }), 1000);
                    }
                }

                if (data.status === 'rps') {
                    if(document.getElementById('rps-ui').classList.contains('hidden')) {
                        document.getElementById('overlay-title').innerText = "ê°€ìœ„ë°”ìœ„ë³´!";
                        document.getElementById('rps-ui').classList.remove('hidden');
                        document.getElementById('match-status').innerText = "ì„ íƒí•˜ì„¸ìš”.";
                    }
                    if(data.rps_host && data.rps_guest) {
                        judgeRPS(data.rps_host, data.rps_guest);
                    }
                }

                if (data.status === 'playing') {
                    if(!document.getElementById('overlay-screen').classList.contains('hidden')) {
                        document.getElementById('overlay-screen').classList.add('hidden');
                        document.getElementById('top-info').classList.remove('hidden');
                        document.getElementById('bottom-panel').classList.remove('hidden');
                        log("ê²Œì„ Start!");
                    }
                    
                    const s = JSON.parse(data.gameState); 
                    state.currentTurn = s.currentTurn; 
                    state.phase = s.phase; 
                    state.pieces = s.pieces; 
                    state.placeCount = s.placeCount; 
                    state.winner = s.winner;
                    
                    rebuildBoard(); 
                    renderAll(); 
                    updateUI();
                }
            });
        }

        function setupInitialPieces() {
            addPieceData('s1', 'p1', 1, 1, 0, 'flat');
            addPieceData('s2', 'p2', 3, 3, 2, 'flat');
            renderAll();
        }

        window.chooseRPS = (choice) => { 
            const updates = {}; 
            updates[state.myRole==='host'?'rps_host':'rps_guest']=choice; 
            update(roomRef, updates); 
            document.getElementById('rps-ui').classList.add('hidden'); 
            document.getElementById('match-status').innerText = "ìƒëŒ€ ëŒ€ê¸° ì¤‘..."; 
        };

        function judgeRPS(h, g) {
            if (h === g) { 
                if(state.myRole === 'host') {
                    setTimeout(()=>update(roomRef, {rps_host:null, rps_guest:null}), 1000); 
                }
                log("ê°€ìœ„ë°”ìœ„ë³´ ë¹„ê¹€");
                document.getElementById('overlay-title').innerText = "ë¹„ê²¼ìŠµë‹ˆë‹¤!"; 
                setTimeout(() => {
                    document.getElementById('rps-ui').classList.remove('hidden'); 
                }, 1000);
                return; 
            }
            
            const winMap = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
            const hostWins = winMap[h] === g;
            
            state.myRole = (state.myRole === 'host' ? (hostWins?'p1':'p2') : (hostWins?'p2':'p1'));
            log(`ë‚´ ì—­í• : ${state.myRole}`);
            
            if (state.myRole === 'p1') { 
                const initS = { 
                    currentTurn:'p1', 
                    phase:'place', 
                    pieces:[{id:'s1',owner:'p1',x:1,z:1,rot:0,mode:'flat'}, {id:'s2',owner:'p2',x:3,z:3,rot:2,mode:'flat'}], 
                    placeCount:{p1:1,p2:1} 
                };
                update(roomRef, { status: 'playing', gameState: JSON.stringify(initS) });
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 6);
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5); light.position.set(5, 10, 2); scene.add(light);
            scene.add(new THREE.GridHelper(5, 5, 0x4CAF50, 0x222222));
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5,5), new THREE.MeshStandardMaterial({color:0x0a0a0a}));
            floor.rotation.x = -Math.PI/2; floor.name = "floor"; scene.add(floor);
            ghostGroup = new THREE.Group(); boardGroup = new THREE.Group(); scene.add(ghostGroup, boardGroup);
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            animate();
        }

        function createCube(x, y, z, color, isSelected) {
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), new THREE.MeshStandardMaterial({ color }));
            mesh.position.set(x-2, y+0.5, z-2);
            group.add(mesh);
            const edgeMat = new THREE.LineBasicMaterial({ color: isSelected?0xffffff:0x000000, transparent:!isSelected, opacity:isSelected?1:0.2 });
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), edgeMat);
            edges.position.copy(mesh.position);
            group.add(edges);
            return group;
        }

        function renderAll() {
            boardGroup.clear();
            state.board.forEach((stack, idx) => {
                stack.forEach(c => boardGroup.add(createCube(idx%5, c.layer, Math.floor(idx/5), c.owner==='p1'?0xaa0000:0x0055aa, state.selectedId===c.pieceId)));
            });
            checkWin(); updateUI();
        }

        function rebuildBoard() {
            state.board = Array(25).fill().map(() => []);
            state.pieces.forEach(p => {
                getOffsets(p.mode, p.rot).forEach(o => {
                    const idx = (p.z+o[2])*5 + (p.x+o[0]);
                    if(state.board[idx]) state.board[idx].push({ owner:p.owner, pieceId:p.id, layer:o[1] });
                });
            });
        }

        function showToast(msg) {
            const toast = document.getElementById('toast-msg');
            toast.innerText = msg;
            toast.style.opacity = '1';
            clearTimeout(window.toastTimer);
            window.toastTimer = setTimeout(() => {
                toast.style.opacity = '0';
            }, 1500);
        }

        function validateMove(gx, gz, rot, mode, ignoreId = null) {
            const offsets = getOffsets(mode, rot);
            if(!offsets.every(o => {
                const nx = gx + o[0]; const nz = gz + o[2];
                return nx >= 0 && nx < 5 && nz >= 0 && nz < 5;
            })) return { valid: false, msg: "ê²½ê¸°ì¥ì„ ë²—ì–´ë‚©ë‹ˆë‹¤!" };

            const tempBoard = JSON.parse(JSON.stringify(state.board));
            if(ignoreId) for(let i=0; i<25; i++) tempBoard[i] = tempBoard[i].filter(c => c.pieceId !== ignoreId);

            for (let i = 0; i < offsets.length; i++) {
                const o = offsets[i];
                const nx = gx + o[0]; const nz = gz + o[2]; const ny = o[1];
                if (tempBoard[nz*5 + nx].some(c => c.layer === ny)) return { valid: false, msg: "ì´ë¯¸ ë¸”ë¡ì´ ìˆìŠµë‹ˆë‹¤!" };
                if (ny > 0) {
                    const hasBoardSupport = tempBoard[nz*5 + nx].some(c => c.layer === ny - 1);
                    const hasSelfSupport = offsets.some(other => other[0] === o[0] && other[2] === o[2] && other[1] === ny - 1);
                    if (!hasBoardSupport && !hasSelfSupport) return { valid: false, msg: "ê³µì¤‘ì— ë–  ìˆìŠµë‹ˆë‹¤! (ë°›ì¹¨ í•„ìš”)" };
                }
            }
            return { valid: true };
        }

        function canPlace(gx, gz, rot, mode, ignoreId = null) { return validateMove(gx, gz, rot, mode, ignoreId).valid; }

        function handleCellClick(gx, gz) {
            if(state.winner || state.currentTurn !== state.myRole) return;
            state.pendingMove = null;
            document.getElementById('confirm-btn').style.display = 'none';

            if(state.phase === 'place') {
                const check = validateMove(gx, gz, state.rotation, state.placeMode);
                if(check.valid) {
                    state.pendingMove = { type: 'place', x: gx, z: gz, rot: state.rotation, mode: state.placeMode };
                    document.getElementById('confirm-btn').style.display = 'block';
                } else {
                    showToast(check.msg);
                }
            } else {
                const stack = state.board[gz*5+gx];
                const top = stack.length > 0 ? stack.sort((a,b)=>b.layer-a.layer)[0] : null;
                if(!state.selectedId) {
                    if(top && top.owner === state.myRole) {
                        state.selectedId = top.pieceId;
                        const p = state.pieces.find(pc => pc.id === state.selectedId);
                        state.rotation = p.rot; state.placeMode = p.mode; renderAll();
                    }
                } else {
                    const check = validateMove(gx, gz, state.rotation, state.placeMode, state.selectedId);
                    if(check.valid) {
                         state.pendingMove = { type: 'move', x: gx, z: gz, rot: state.rotation, mode: state.placeMode };
                         document.getElementById('confirm-btn').style.display = 'block';
                    } else { 
                        state.selectedId = null; renderAll(); 
                        showToast(check.msg);
                    }
                }
            }
        }

        window.confirmMove = () => {
            if (!state.pendingMove) return;
            const pm = state.pendingMove;
            if (pm.type === 'place') {
                addPieceData(Math.random().toString(36), state.myRole, pm.x, pm.z, pm.rot, pm.mode);
                state.placeCount[state.myRole]++;
                finishTurn();
            } else if (pm.type === 'move') {
                const p = state.pieces.find(pc => pc.id === state.selectedId);
                Object.assign(p, { x: pm.x, z: pm.z, rot: pm.rot, mode: pm.mode });
                state.selectedId = null;
                finishTurn();
            }
            state.pendingMove = null;
            document.getElementById('confirm-btn').style.display = 'none';
        };

        function finishTurn() {
            state.currentTurn = state.currentTurn === 'p1' ? 'p2' : 'p1';
            if(state.placeCount.p1 >= 5 && state.placeCount.p2 >= 5) state.phase = 'move';
            if(state.mode === 'online') pushOnline();
            else { rebuildBoard(); renderAll(); if(state.mode === 'ai' && state.currentTurn === 'p2') doAI(); }
        }

        function pushOnline() {
            const data = { currentTurn: state.currentTurn, phase: state.phase, pieces: state.pieces, placeCount: state.placeCount, winner: state.winner };
            update(roomRef, { gameState: JSON.stringify(data) });
        }

        function addPieceData(id, owner, x, z, rot, mode) {
            state.pieces.push({ id, owner, x, z, rot, mode });
            rebuildBoard();
        }

        function checkWin() {
            const top = state.board.map(s => s.length > 0 ? s.sort((a,b)=>b.layer-a.layer)[0].owner : null);
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            for(let l of lines) {
                if(top[l[0]] && l.every(i => top[i] === top[l[0]])) {
                    state.winner = top[l[0]];
                    document.getElementById('status-msg').innerText = (state.winner === 'p1' ? 'ë¹¨ê°•' : 'íŒŒë‘') + "íŒ€ ìŠ¹ë¦¬!";
                }
            }
        }

        function doAI() {
            if (state.winner || state.currentTurn !== 'p2') return;
            setTimeout(() => {
                const moves = getAllValidMoves('p2');
                if (moves.length === 0) return;
                moves.forEach(m => m.score = evaluateBoardState(m, 'p2'));
                moves.sort((a, b) => b.score - a.score);
                const best = moves[0];
                if (state.phase === 'place') {
                    addPieceData(Math.random().toString(36), 'p2', best.x, best.z, best.r, best.m);
                    state.placeCount.p2++;
                } else {
                    const p = state.pieces.find(pc => pc.id === best.targetId);
                    Object.assign(p, { x: best.x, z: best.z, rot: best.r, mode: best.m });
                    rebuildBoard();
                }
                finishTurn();
            }, 500);
        }
        function getAllValidMoves(player) {
            const validMoves = [];
            const modes = ['flat', 'vertical'];
            for (let x = 0; x < 5; x++) {
                for (let z = 0; z < 5; z++) {
                    for (let r = 0; r < 4; r++) {
                        for (let m of modes) {
                            if (state.phase === 'place') {
                                if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m });
                            } else {
                                state.pieces.filter(p => p.owner === player).forEach(targetPiece => {
                                    const backupBoard = JSON.parse(JSON.stringify(state.board));
                                    state.board = state.board.map(s => s.filter(c => c.pieceId !== targetPiece.id));
                                    if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m, targetId: targetPiece.id });
                                    state.board = backupBoard;
                                });
                            }
                        }
                    }
                }
            }
            return validMoves;
        }
        function evaluateBoardState(move, aiPlayer) {
            const humanPlayer = aiPlayer === 'p1' ? 'p2' : 'p1';
            let totalScore = 0;
            const offsets = getOffsets(move.m, move.r);
            let simTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            offsets.forEach(o => { const idx = (move.z + o[2]) * 5 + (move.x + o[0]); simTop[idx] = aiPlayer; });
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            totalScore += evaluateLines(lines, simTop, aiPlayer, humanPlayer) * 1.2; 
            let currentTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            let opponentThreatScore = evaluateLines(lines, currentTop, humanPlayer, aiPlayer);
            if (opponentThreatScore > 5000) totalScore += opponentThreatScore * 10;
            else totalScore += opponentThreatScore * 0.8;
            if (move.x === 2 && move.z === 2) totalScore += 50;
            return totalScore;
        }
        function evaluateLines(lines, boardState, me, opp) {
            let score = 0;
            for (let l of lines) {
                let myCnt = 0, oppCnt = 0, emptyCnt = 0;
                let pattern = "";
                l.forEach(i => { if (boardState[i] === me) { myCnt++; pattern += "O"; } else if (boardState[i] === opp) { oppCnt++; pattern += "X"; } else { emptyCnt++; pattern += "_"; } });
                if (oppCnt === 0) { 
                    if (myCnt === 5) score += 1000000; 
                    else if (myCnt === 4) score += 50000; 
                    else if (myCnt === 3) { if (pattern.includes("_OOO_") || pattern.includes("_OOO") || pattern.includes("OOO_")) score += 5000; else score += 1000; }
                    else if (myCnt === 2 && emptyCnt === 3) score += 100;
                }
            }
            return score;
        }

        function updateUI() {
            document.getElementById('role-label').innerText = state.myRole==='p1'?"ğŸ”´ ë‚˜ (ì„ )":state.myRole==='p2'?"ğŸ”µ ë‚˜ (í›„)":"ê´€ì „";
            document.getElementById('turn-label').innerText = state.currentTurn===state.myRole?"ë‚´ í„´":"ìƒëŒ€ í„´";
            document.getElementById('turn-label').style.color = state.currentTurn === state.myRole ? '#4CAF50' : '#888';
            document.getElementById('phase-ui').innerText = state.phase === 'place' ? "ì°©ìˆ˜ ë‹¨ê³„" : "ì´ë™ ë‹¨ê³„";
        }

        function animate() {
            requestAnimationFrame(animate); controls.update(); ghostGroup.clear();
            
            if(state.pendingMove) {
                const pm = state.pendingMove;
                getOffsets(pm.mode, pm.rot).forEach(o => ghostGroup.add(createCube(pm.x+o[0], o[1], pm.z+o[2], 0x4CAF50, false)));
            } else if(!state.winner && state.currentTurn === state.myRole) {
                raycaster.setFromCamera(mouse, camera);
                const floor = raycaster.intersectObjects(scene.children).find(h => h.object.name === "floor");
                if(floor) {
                    const gx = Math.round(floor.point.x+2), gz = Math.round(floor.point.z+2);
                    if(canPlace(gx, gz, state.rotation, state.placeMode, state.selectedId)) {
                        getOffsets(state.placeMode, state.rotation).forEach(o => ghostGroup.add(createCube(gx+o[0], o[1], gz+o[2], 0x444444, false)));
                    }
                }
            }
            renderer.render(scene, camera);
        }

        window.rotatePiece = () => { 
            state.rotation++; 
            if(state.pendingMove) { state.pendingMove.rot = state.rotation; }
        };
        window.togglePlaceMode = () => { 
            state.placeMode = state.placeMode === 'flat' ? 'vertical' : 'flat'; 
            document.getElementById('mode-btn').innerText = `ëª¨ë“œ: ${state.placeMode === 'flat' ? 'ëˆ•íˆê¸°' : 'ì„¸ìš°ê¸°'}`; 
            if(state.pendingMove) { state.pendingMove.mode = state.placeMode; }
        };
        window.toggleTopView = () => { state.isTopView = !state.isTopView; if(state.isTopView) { camera.position.set(0, 12, 6); camera.lookAt(0,0,0); controls.enabled = false; } else { camera.position.set(6, 7, 6); controls.enabled = true; } };

        const updateM = (x, y) => { mouse.x = (x/window.innerWidth)*2-1; mouse.y = -(y/window.innerHeight)*2+1; };
        const clk = (e) => { 
            const x = e.clientX||(e.touches&&e.touches[0].clientX); 
            const y = e.clientY||(e.touches&&e.touches[0].clientY); 
            if(x) updateM(x, y); 
            raycaster.setFromCamera(mouse, camera); 
            const f = raycaster.intersectObjects(scene.children).find(h => h.object.name === "floor"); 
            if(f) handleCellClick(Math.round(f.point.x+2), Math.round(f.point.z+2)); 
        };
        window.addEventListener('mousemove', (e) => updateM(e.clientX, e.clientY)); 
        window.addEventListener('click', clk); 
        window.addEventListener('touchstart', clk);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
