<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ëŒ€í•™ì „ìŸ3 - ë¸”ë¡ ì˜¤ëª© (Mobile Optimized)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: 'Pretendard', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* ìƒë‹¨ ìƒíƒœë°” */
        #top-bar { position: absolute; top: 0; left: 0; width: 100%; padding: 15px 10px; background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%); pointer-events: none; z-index: 10; display: flex; justify-content: space-between; align-items: flex-start; box-sizing: border-box; }
        .status-badge { background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); font-size: 14px; backdrop-filter: blur(5px); font-weight: bold; text-shadow: 0 1px 2px black; }
        #turn-indicator { transition: 0.3s; }

        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ëŸ¬ (í•µì‹¬ UI) */
        #bottom-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 160px; background: linear-gradient(0deg, #000 0%, rgba(0,0,0,0) 100%); z-index: 20; display: flex; flex-direction: column; justify-content: flex-end; padding-bottom: 20px; box-sizing: border-box; pointer-events: none; }
        .control-row { display: flex; justify-content: center; gap: 15px; margin-bottom: 15px; pointer-events: auto; width: 100%; padding: 0 20px; box-sizing: border-box; }
        
        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn-circle { width: 60px; height: 60px; border-radius: 50%; border: none; background: rgba(50, 50, 50, 0.9); color: white; font-size: 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); active: scale(0.9); transition: 0.1s; display: flex; justify-content: center; align-items: center; border: 2px solid rgba(255,255,255,0.1); }
        .btn-circle:active { transform: scale(0.95); background: #444; }
        .btn-pill { flex: 1; height: 60px; border-radius: 30px; border: none; background: #4CAF50; color: white; font-size: 20px; font-weight: bold; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); display: flex; justify-content: center; align-items: center; text-transform: uppercase; letter-spacing: 1px; }
        .btn-pill:active { transform: scale(0.98); filter: brightness(0.9); }
        .btn-pill.disabled { background: #333; color: #777; box-shadow: none; }

        /* ë¡œë¹„ & ì˜¤ë²„ë ˆì´ */
        .fullscreen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 10, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; backdrop-filter: blur(10px); }
        .panel { width: 85%; max-width: 320px; text-align: center; }
        h1 { font-size: 24px; color: #4CAF50; margin-bottom: 30px; letter-spacing: 2px; }
        .main-btn { width: 100%; padding: 15px; margin: 8px 0; background: #222; border: 1px solid #444; color: white; border-radius: 12px; font-size: 16px; font-weight: bold; }
        .main-btn.primary { background: #4CAF50; color: #000; border: none; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }

        .hidden { display: none !important; }
    </style>
    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js"
        } }
    </script>
</head>
<body>
    <canvas id="game-canvas"></canvas>

    <div id="top-bar" class="hidden">
        <div class="status-badge" id="role-badge">P1 (Red)</div>
        <div class="status-badge" id="turn-badge" style="background:#ff4444; color:white;">ë‚´ í„´</div>
    </div>

    <div id="bottom-controls" class="hidden">
        <div class="control-row">
            <button class="btn-circle" onclick="togglePlaceMode()">ğŸ”„<span style="font-size:10px; position:absolute; bottom:8px;">ëª¨ë“œ</span></button>
            <button class="btn-circle" onclick="rotatePiece()">â†ªï¸<span style="font-size:10px; position:absolute; bottom:8px;">íšŒì „</span></button>
        </div>
        <div class="control-row">
            <button id="confirm-btn" class="btn-pill disabled" onclick="confirmMove()">ì°© ìˆ˜ (V)</button>
        </div>
    </div>

    <div id="lobby" class="fullscreen-overlay">
        <div class="panel">
            <h1>BLOCK OMOK<br><span style="font-size:14px; color:#888;">MOBILE EDITION</span></h1>
            <button class="main-btn primary" onclick="startMode('ai')">ğŸ¤– AI ëŒ€ê²° ì‹œì‘</button>
            <div style="margin: 20px 0; border-top:1px solid #333;"></div>
            <input type="number" id="room-input" placeholder="ë°© ì½”ë“œ (ìˆ«ì)" style="width:100%; padding:15px; background:#111; border:1px solid #333; color:white; border-radius:12px; text-align:center; font-size:18px; margin-bottom:10px;">
            <button class="main-btn" onclick="startMode('online')">ğŸ‘¥ ì˜¨ë¼ì¸ ëŒ€ê²°</button>
        </div>
    </div>

    <div id="msg-overlay" class="fullscreen-overlay hidden">
        <h2 id="msg-title" style="color:#4CAF50; font-size:28px;"></h2>
        <p id="msg-desc" style="color:#aaa; margin-top:10px;"></p>
        <button id="msg-btn" class="main-btn hidden" onclick="location.reload()" style="width:200px; margin-top:30px;">ë‚˜ê°€ê¸°</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "firebase/app";
        import { getDatabase, ref, set, onValue, update } from "firebase/database";

        // Firebase ì„¤ì • (ê¸°ì¡´ê³¼ ë™ì¼)
        const firebaseConfig = {
            apiKey: "AIzaSyDcKWKTei9L2Sat-XxinlXknabIcHgmjGs",
            authDomain: "d454545-ac9b1.firebaseapp.com",
            projectId: "d454545-ac9b1",
            databaseURL: "https://d454545-ac9b1-default-rtdb.firebaseio.com"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        const state = {
            mode: 'ai', myRole: 'p1', currentTurn: 'p1', phase: 'place',
            board: Array(25).fill().map(() => []),
            pieces: [], placeCount: { p1: 1, p2: 1 },
            placeMode: 'flat', selectedId: null, rotation: 0, winner: null,
            // ëª¨ë°”ì¼ ì „ìš© ìƒíƒœ:
            ghostPos: null, // í˜„ì¬ ì‚¬ìš©ìê°€ 'ë³´ê³  ìˆëŠ”' ìœ„ì¹˜ {x, z}
        };

        let scene, camera, renderer, controls, raycaster, mouse;
        let ghostGroup, boardGroup, roomRef;
        const flatOffsets = [[[0,0,0], [1,0,0], [0,0,1]], [[0,0,0], [0,0,1], [-1,0,0]], [[0,0,0], [-1,0,0], [0,0,-1]], [[0,0,0], [0,0,-1], [1,0,0]]];
        const vertOffsets = [[[0,0,0], [0,1,0], [1,1,0]], [[0,0,0], [0,1,0], [0,1,1]], [[0,0,0], [0,1,0], [-1,1,0]], [[0,0,0], [0,1,0], [0,1,-1]]];
        function getOffsets(mode, rot) { return (mode === 'flat' ? flatOffsets : vertOffsets)[rot % 4]; }

        // --- ì´ˆê¸°í™” ---
        window.startMode = (mode) => {
            state.mode = mode;
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('top-bar').classList.remove('hidden');
            document.getElementById('bottom-controls').classList.remove('hidden');
            initThree();
            if(mode === 'online') {
                const id = document.getElementById('room-input').value;
                if(!id) return alert('ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”');
                setupMatching(id);
            } else {
                setupInitialPieces();
            }
        };

        function setupInitialPieces() {
            addPieceData('s1', 'p1', 1, 1, 0, 'flat');
            addPieceData('s2', 'p2', 3, 3, 2, 'flat');
            renderAll();
        }

        // --- Three.js (ëª¨ë°”ì¼ ë·° ìµœì í™”) ---
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // ë°°ê²½ ì¡°ê¸ˆ ë” ë°ê²Œ

            // ì¹´ë©”ë¼ëŠ” ì¿¼í„°ë·°(Isometric ëŠë‚Œ)ê°€ ëª¨ë°”ì¼ì—ì„œ ê¹Šì´ê° ë³´ê¸°ì— ì¢‹ìŒ
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 10, 8); // ì•½ê°„ ê¸°ìš¸ì–´ì§„ ê°ë„
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // OrbitControls í™œì„±í™” (í„°ì¹˜ë¡œ íšŒì „ ê°€ëŠ¥)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // ë•… ë°‘ìœ¼ë¡œ ëª» ê°€ê²Œ ì œí•œ
            controls.minDistance = 3;
            controls.maxDistance = 20;

            // ì¡°ëª… ê°•í™”
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 15, 5);
            scene.add(dirLight);

            // ë°”ë‹¥ ê·¸ë¦¬ë“œ
            const grid = new THREE.GridHelper(5, 5, 0x444444, 0x222222);
            scene.add(grid);
            
            // íˆ¬ëª… í„°ì¹˜ í”Œë ˆì¸
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshBasicMaterial({ visible: false }));
            floor.rotation.x = -Math.PI/2;
            floor.name = "floor";
            scene.add(floor);

            ghostGroup = new THREE.Group();
            boardGroup = new THREE.Group();
            scene.add(ghostGroup, boardGroup);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            animate();
        }

        // --- í•µì‹¬ ë¡œì§: í„°ì¹˜ -> ê³ ìŠ¤íŠ¸ ì´ë™ -> ì°©ìˆ˜ ë²„íŠ¼ í´ë¦­ ---
        function onTouch(e) {
            // í„°ì¹˜/í´ë¦­ ì¢Œí‘œ ë³€í™˜
            let clientX, clientY;
            if (e.changedTouches) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            const floorHit = intersects.find(h => h.object.name === 'floor');

            if (floorHit) {
                // ê·¸ë¦¬ë“œ ì¢Œí‘œ ê³„ì‚° (ë°˜ì˜¬ë¦¼)
                const gx = Math.round(floorHit.point.x + 2);
                const gz = Math.round(floorHit.point.z + 2);

                if (gx >= 0 && gx < 5 && gz >= 0 && gz < 5) {
                    state.ghostPos = { x: gx, z: gz };
                    updateGhost();
                    vibrate(10); // ì•½í•œ ì§„ë™
                }
            }
        }

        // ê³ ìŠ¤íŠ¸(ì˜ˆìƒ ìœ„ì¹˜) ì—…ë°ì´íŠ¸
        function updateGhost() {
            ghostGroup.clear();
            const btn = document.getElementById('confirm-btn');
            
            if (state.winner || state.currentTurn !== state.myRole || !state.ghostPos) {
                btn.classList.add('disabled');
                return;
            }

            const { x, z } = state.ghostPos;
            let isValid = false;

            if (state.phase === 'place') {
                isValid = canPlace(x, z, state.rotation, state.placeMode);
            } else {
                // ì´ë™ ë‹¨ê³„ ë¡œì§ (ì„ íƒëœ ë§ì´ ìˆì–´ì•¼ í•¨)
                if (!state.selectedId) {
                    // ë‚´ ë§ì„ ì„ íƒí•˜ëŠ” ë‹¨ê³„
                    const stack = state.board[z*5+x];
                    const top = stack.length > 0 ? stack.sort((a,b)=>b.layer-a.layer)[0] : null;
                    if (top && top.owner === state.myRole) {
                        // ì„ íƒ í‘œì‹œ (í•˜ì´ë¼ì´íŠ¸)
                        const outline = createCube(x, top.layer, z, 0xffff00, true);
                        ghostGroup.add(outline);
                        btn.innerText = "ì„ íƒ í•˜ê¸°";
                        btn.classList.remove('disabled');
                        return;
                    }
                } else {
                    // ì„ íƒëœ ë§ì„ ì´ë™ì‹œí‚¬ ìœ„ì¹˜
                    isValid = canPlace(x, z, state.rotation, state.placeMode, state.selectedId);
                }
            }

            if (isValid) {
                btn.classList.remove('disabled');
                btn.innerText = state.phase === 'place' ? "ì—¬ê¸°ì— ì°©ìˆ˜" : "ì—¬ê¸°ë¡œ ì´ë™";
                const color = state.myRole === 'p1' ? 0xffaaaa : 0xaaaaHf;
                
                // ê³ ìŠ¤íŠ¸ ë Œë”ë§
                getOffsets(state.placeMode, state.rotation).forEach(o => {
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
                    mesh.position.set(x + o[0] - 2, o[1] + 0.5, z + o[2] - 2);
                    ghostGroup.add(mesh);
                });
            } else {
                btn.classList.add('disabled');
            }
        }

        // --- ë²„íŠ¼ ì•¡ì…˜ ---
        window.confirmMove = () => {
            if (document.getElementById('confirm-btn').classList.contains('disabled')) return;
            
            vibrate(50); // ê°•í•œ ì§„ë™
            const { x, z } = state.ghostPos;

            if (state.phase === 'place') {
                addPieceData(Math.random().toString(), state.myRole, x, z, state.rotation, state.placeMode);
                state.placeCount[state.myRole]++;
                finishTurn();
            } else {
                // ì´ë™ ë‹¨ê³„
                if (!state.selectedId) {
                    // ë§ ì„ íƒ í™•ì •
                    const stack = state.board[z*5+x];
                    const top = stack.sort((a,b)=>b.layer-a.layer)[0];
                    state.selectedId = top.pieceId;
                    
                    // í•´ë‹¹ ë§ì˜ ì†ì„± ê°€ì ¸ì˜¤ê¸°
                    const p = state.pieces.find(pc => pc.id === state.selectedId);
                    state.rotation = p.rot; state.placeMode = p.mode;
                    
                    state.ghostPos = null; // ìœ„ì¹˜ ì´ˆê¸°í™”
                    renderAll(); // ì„ íƒ ìƒíƒœ ê°±ì‹ 
                    updateGhost();
                } else {
                    // ì´ë™ í™•ì •
                    const p = state.pieces.find(pc => pc.id === state.selectedId);
                    Object.assign(p, { x, z, rot: state.rotation, mode: state.placeMode });
                    state.selectedId = null;
                    state.ghostPos = null;
                    finishTurn();
                }
            }
        };

        window.togglePlaceMode = () => {
            state.placeMode = state.placeMode === 'flat' ? 'vertical' : 'flat';
            vibrate(10);
            updateGhost();
        };

        window.rotatePiece = () => {
            state.rotation++;
            vibrate(10);
            updateGhost();
        };

        function vibrate(ms) {
            if (navigator.vibrate) navigator.vibrate(ms);
        }

        // --- ê²Œì„ ë¡œì§ (ê¸°ì¡´ ê³ ì§€ëŠ¥ AI í¬í•¨) ---
        function createCube(x, y, z, color, isSelected) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.5 }));
            mesh.position.set(x-2, y+0.5, z-2);
            if (isSelected) mesh.material.emissive = new THREE.Color(0x333333);
            return mesh;
        }

        function renderAll() {
            boardGroup.clear();
            state.board.forEach((stack, idx) => {
                stack.forEach(c => {
                    const isSelected = state.selectedId === c.pieceId;
                    const color = c.owner === 'p1' ? 0xd32f2f : 0x1976D2; // ìƒ‰ìƒ ì¡°ê¸ˆ ë” ì§„í•˜ê²Œ
                    boardGroup.add(createCube(idx%5, c.layer, Math.floor(idx/5), color, isSelected));
                });
            });
            checkWin();
            updateUI();
        }

        function rebuildBoard() {
            state.board = Array(25).fill().map(() => []);
            state.pieces.forEach(p => {
                getOffsets(p.mode, p.rot).forEach(o => {
                    const idx = (p.z+o[2])*5 + (p.x+o[0]);
                    if(state.board[idx]) state.board[idx].push({ owner:p.owner, pieceId:p.id, layer:o[1] });
                });
            });
        }

        function canPlace(gx, gz, rot, mode, ignoreId = null) {
            const offsets = getOffsets(mode, rot);
            if(!offsets.every(o => (gx+o[0]>=0 && gx+o[0]<5 && gz+o[2]>=0 && gz+o[2]<5))) return false;
            const tempBoard = JSON.parse(JSON.stringify(state.board));
            if(ignoreId) for(let i=0; i<25; i++) tempBoard[i] = tempBoard[i].filter(c => c.pieceId !== ignoreId);
            for(let o of offsets) {
                const nx = gx+o[0], nz = gz+o[2], ny = o[1];
                if(tempBoard[nz*5+nx].some(c => c.layer === ny)) return false;
                if(ny > 0) {
                    const hasSup = offsets.some(p => p[0]===o[0] && p[2]===o[2] && p[1]===ny-1) || tempBoard[nz*5+nx].some(c => c.layer === ny-1);
                    if(!hasSup) return false;
                }
            }
            return true;
        }

        function finishTurn() {
            state.currentTurn = state.currentTurn === 'p1' ? 'p2' : 'p1';
            state.ghostPos = null;
            ghostGroup.clear();
            document.getElementById('confirm-btn').classList.add('disabled');
            
            if(state.placeCount.p1 >= 5 && state.placeCount.p2 >= 5) state.phase = 'move';
            
            if(state.mode === 'online') pushOnline();
            else { 
                rebuildBoard(); 
                renderAll(); 
                if(state.mode === 'ai' && state.currentTurn === 'p2') doAI(); 
            }
        }

        function checkWin() {
            const top = state.board.map(s => s.length > 0 ? s.sort((a,b)=>b.layer-a.layer)[0].owner : null);
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            for(let l of lines) {
                if(top[l[0]] && l.every(i => top[i] === top[l[0]])) {
                    state.winner = top[l[0]];
                    showMsg((state.winner === 'p1' ? 'RED' : 'BLUE') + " ìŠ¹ë¦¬!", "ì¶•í•˜í•©ë‹ˆë‹¤!");
                }
            }
        }

        function doAI() {
            if (state.winner || state.currentTurn !== 'p2') return;
            // ëª¨ë°”ì¼ì—ì„œëŠ” AI ìƒê°í•˜ëŠ” ì‹œê°„ë™ì•ˆ UI ì ê¸ˆ í•„ìš”í•˜ì§€ë§Œ ì•½ì‹ìœ¼ë¡œ ì²˜ë¦¬
            setTimeout(() => {
                const moves = getAllValidMoves('p2');
                if (moves.length === 0) return;
                moves.forEach(m => m.score = evaluateBoardState(m, 'p2'));
                moves.sort((a, b) => b.score - a.score);
                const best = moves[0];
                if (state.phase === 'place') {
                    addPieceData(Math.random().toString(), 'p2', best.x, best.z, best.r, best.m);
                    state.placeCount.p2++;
                } else {
                    const p = state.pieces.find(pc => pc.id === best.targetId);
                    Object.assign(p, { x: best.x, z: best.z, rot: best.r, mode: best.m });
                    rebuildBoard();
                }
                finishTurn();
            }, 800);
        }

        // (AI ê´€ë ¨ í•¨ìˆ˜ë“¤ì€ ê¸°ì¡´ê³¼ ë™ì¼ - ìƒëµ ì—†ì´ í¬í•¨)
        function getAllValidMoves(player) {
            const validMoves = []; const modes = ['flat', 'vertical'];
            for (let x = 0; x < 5; x++) for (let z = 0; z < 5; z++) for (let r = 0; r < 4; r++) for (let m of modes) {
                if (state.phase === 'place') { if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m }); } 
                else { state.pieces.filter(p => p.owner === player).forEach(targetPiece => {
                    const backupBoard = JSON.parse(JSON.stringify(state.board));
                    state.board = state.board.map(s => s.filter(c => c.pieceId !== targetPiece.id));
                    if (canPlace(x, z, r, m)) validMoves.push({ x, z, r, m, targetId: targetPiece.id });
                    state.board = backupBoard;
                });}
            }
            return validMoves;
        }
        function evaluateBoardState(move, aiPlayer) {
            const humanPlayer = aiPlayer === 'p1' ? 'p2' : 'p1';
            let totalScore = 0;
            const offsets = getOffsets(move.m, move.r);
            let simTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            offsets.forEach(o => { simTop[(move.z + o[2]) * 5 + (move.x + o[0])] = aiPlayer; });
            const lines = [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],[0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],[0,6,12,18,24],[4,8,12,16,20]];
            totalScore += evaluateLines(lines, simTop, aiPlayer, humanPlayer) * 1.2;
            let currentTop = state.board.map(s => s.length > 0 ? s.sort((a, b) => b.layer - a.layer)[0].owner : null);
            let opponentThreatScore = evaluateLines(lines, currentTop, humanPlayer, aiPlayer);
            if (opponentThreatScore > 5000) totalScore += opponentThreatScore * 15; else totalScore += opponentThreatScore * 0.8;
            if (move.x === 2 && move.z === 2) totalScore += 50;
            return totalScore;
        }
        function evaluateLines(lines, boardState, me, opp) {
            let score = 0;
            for (let l of lines) {
                let myCnt = 0, oppCnt = 0;
                l.forEach(i => { if (boardState[i] === me) myCnt++; else if (boardState[i] === opp) oppCnt++; });
                if (oppCnt === 0) {
                    if (myCnt === 5) score += 1000000; else if (myCnt === 4) score += 50000; else if (myCnt === 3) score += 5000; else if (myCnt === 2) score += 100;
                }
            }
            return score;
        }

        // --- Firebase ë§¤ì¹­ ë° Utils ---
        function setupMatching(id) {
            state.matchingId = id; showMsg("ëŒ€ê¸° ì¤‘...", "ìƒëŒ€ë°© ì ‘ì†ì„ ê¸°ë‹¤ë¦½ë‹ˆë‹¤ (ë°©ë²ˆí˜¸: "+id+")");
            roomRef = ref(db, 'rooms/' + id);
            onValue(roomRef, (snap) => {
                const data = snap.val();
                if (!data) { state.myRole = 'host'; set(roomRef, { hostJoined: true, status: 'waiting' }); }
                else {
                    if (data.status === 'waiting' && state.myRole !== 'host') { state.myRole = 'guest'; update(roomRef, { status: 'matching_complete' }); }
                    if (data.status === 'matching_complete') showMsg("ë§¤ì¹­ ì™„ë£Œ!", "ì ì‹œ í›„ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤.");
                    if (data.status === 'playing') {
                        document.getElementById('msg-overlay').classList.add('hidden');
                        const s = JSON.parse(data.gameState);
                        state.currentTurn = s.currentTurn; state.phase = s.phase; state.pieces = s.pieces; state.placeCount = s.placeCount; state.winner = s.winner;
                        rebuildBoard(); renderAll();
                    }
                }
            });
        }
        function pushOnline() {
            const data = { currentTurn: state.currentTurn, phase: state.phase, pieces: state.pieces, placeCount: state.placeCount, winner: state.winner };
            update(roomRef, { gameState: JSON.stringify(data) });
        }
        function addPieceData(id, owner, x, z, rot, mode) {
            state.pieces.push({ id, owner, x, z, rot, mode });
            rebuildBoard();
        }

        function showMsg(title, desc) {
            const el = document.getElementById('msg-overlay');
            el.classList.remove('hidden');
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-desc').innerText = desc;
            if(state.winner) document.getElementById('msg-btn').classList.remove('hidden');
        }

        function updateUI() {
            document.getElementById('role-badge').innerText = state.myRole === 'p1' ? "ğŸŸ¥ ë‚˜: ì„ ê³µ" : "ğŸŸ¦ ë‚˜: í›„ê³µ";
            const turnEl = document.getElementById('turn-badge');
            if (state.currentTurn === state.myRole) {
                turnEl.innerText = "ë‚´ ì°¨ë¡€";
                turnEl.style.background = "#4CAF50";
            } else {
                turnEl.innerText = "ìƒëŒ€ í„´";
                turnEl.style.background = "#555";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        window.addEventListener('click', onTouch);
        window.addEventListener('touchstart', (e) => { 
            // ìº”ë²„ìŠ¤ í„°ì¹˜ ì‹œ ìŠ¤í¬ë¡¤ ë°©ì§€
            if(e.target.id === 'game-canvas') e.preventDefault(); 
        }, {passive: false});
        
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
